\documentclass[11pt]{article}
\bibliographystyle{plain}
\usepackage{geometry}  % set the margins to 1in on all sides
\usepackage{graphics,graphicx}              % to include figures
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usepackage{amsmath}               % great math stuff
\usepackage{amsfonts}              % for blackboard bold, etc
\usepackage{amsthm}                % better theorem environments
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{multirow}

\theoremstyle{plain}
\newtheorem{THE}{Theorem}[section]
\newtheorem{LEM}[THE]{Lemma}
\newtheorem{PROP}[THE]{Proposition}
\newtheorem*{COR}{Corollary}
\newtheorem{PROB}{\bf Problem}[section]
\newtheorem{DEF}{Definition}[section]
\newtheorem{CON}{Conjecture}[section]

\theoremstyle{definition}
\newtheorem{EXA}{\bf Example}[section]
\newtheorem{GAME}{\bf Game}[section]
\newtheorem{CONJ}{\bf Conjecture}[section]

\theoremstyle{remark}
\newtheorem*{REM}{Remark}
\newtheorem*{note}{Note}

% various theorems, numbered by section
\DeclareMathOperator{\id}{id}

\newcommand{\bd}[1]{\mathbf{#1}}  % for bolding symbols
\newcommand{\RR}{\mathbb{R}}      % for Real numbers
\newcommand{\ZZ}{\mathbb{Z}}      % for Integers
\newcommand{\NN}{\mathbb{N}}      % for Integers
\newcommand{\QQ}{\mathbb{Q}}      % for Integers
\newcommand{\A}{\mathbb{A}}   
\newcommand{\U}{\mathcal{U}}  
\newcommand{\col}[1]{\left[\begin{matrix} #1 \end{matrix} \right]}
\newcommand{\comb}[2]{\binom{#1^2 + #2^2}{#1+#2}}
\newcommand{\ee}{\mathbf{e}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\meas}{\mbox{meas}}
\newcommand{\sign}{\mbox{sign}}

\newcommand{\sk}{{\sf sk}}
\newcommand{\pk}{{\sf pk}}
\newcommand{\pks}{{\sf pks}}
\newcommand{\ek}{{\sf ek}}
\newcommand{\key}{{\sf key}}
\newcommand{\err}{{\sf err}}
\newcommand{\Add}{{\sf Add}}
\newcommand{\Mul}{{\sf Mul}}
\newcommand{\Dec}{{\sf Dec}}
\newcommand{\Enc}{{\sf Enc}}
\newcommand{\Eval}{{\sf Eval}}
\newcommand{\MPP}{{\sf MPP}}
\newcommand{\shMPP}{{\sf SharedMPP}}
\newcommand{\KeyGen}{{\sf Keygen}}
\newcommand{\BB}{{\mbox{\bf B}}}
\newcommand{\bb}{{\mbox{\bf b}}}

\newcommand{\rot}{\operatorname{rot}}
\newcommand{\Samp}{{\sf Samp}}

\newcommand{\ie}{i.e.$\!$ }
\newcommand{\eg}{e.g.$\!$ }
\newcommand{\etal}{et al.$\!$ }
\newcommand{\bra}{\langle}
\newcommand{\ket}{\rangle}
\newcommand{\dist}{\mbox{dist}}
\begin{document}


\nocite{*}

\title{A Key-Recovery Attack On Gentry's Ideal Lattice FHE Scheme Via The Adaptive Hidden Parallelepiped Problem}
\author{}%Francisco Jos\' e Vial Prado \\ 
%Laboratoire PRiSM\\
%Universit\'e de Saint-Quentin-en-Yvelines, Versailles, France}

\maketitle

\abstract{The Hidden Parallelepiped problem is to guess the shape of a secret parallelepiped in $\RR^n$ given sufficiently many uniformly distributed points in its interior. Nguyen and Regev proposed an algorithm that solves HPP in order to cryptanalyze GGH and NTRU signature schemes. In this paper, we consider an adaptive variant of HPP, \ie learn the parallelepiped given access to its indicator function. Algorithms solving this can be used to perform key-recovery attacks on Gentry's ideal lattice FHE scheme, since private keys are bases of ideal lattices of $\RR^n$. We propose two algorithms that recover approximations of the parallelepiped. In particular, our second algorithm outputs two neighbor vertices in $O(n\log^2(n))$ adaptive queries to a decryption oracle, allowing full recovery of secret keys in Gentry's scheme when generated by rotations.}

\section{Introduction}
A parallelepiped of $\RR^n$, or parallelotope, is the polytope obtained when translating a point of $\RR^n$ successively in $n$ independent directions. It is set delimited by $2n$ hyperplanes of dimension $n-1$ such that there are exactly $n$ different pairs of parallel hyperplanes. Consider the following.

\medskip

{\bf Adaptive Hidden Parallelepiped Problem (ad-HPP):} Let $P$ be a secret parallelepiped in $\RR^n$ centered at 0 with vertices in $\ZZ^n$. Let $\chi$ be the indicator function of $P$. Given adaptive access to $\chi$ and a superior bound $D$ on the diameter of $P$, recover $P$.
\medskip


Gentry's celebrated first fully homomorphic scheme relies on ideal lattices of $\RR^n$. In particular, the keys $(\sk,\pk)$ are two parallelepipeds of the same volume, such that $\sk$ is quite orthogonal and small, and $\pk$ is eccentric and large (it may look like a long segment of $\RR^n$). The latter one is public and it serves to encrypt messages, implying that any attacker may use it to try and recover information about $\sk$ or the underlying message. In this article we show that an attacker having access to adaptive decryption queries may construct a function that matches the indicator function of $\sk$ in all points of $\RR^n$ with overwhelming probability. With sufficient amount of samples they can use any algorithm solving ad-HPP to find the vertices of $\sk$, or approximate its shape with some precision, which can be enough to recover the parallelepiped.


\subsection{Fully Homomorphic Encryption}
In a groundbreaking sequence of articles \cite{Gentry:2009:CED:1695738.1695784,Gentry:2009:FHE:1834954,Gentry:2009:FHE:1536414.1536440}, Gentry constructed the first fully homomorphic encryption (FHE) scheme. An FHE scheme is a regular public key encryption scheme that allows public processing of ciphertexts, without access to decryption secrets. More precisely, they allow to publicly transform a set of ciphertexts into a new one that encrypts any desired polynomial function on the underlying plaintexts. FHE finds several modern applications, and exciting research has been performed since 2009. In order to fulfill the needs of these applications and to compete with contemporary encryption schemes, optimizations, modifications and new proposals have been appearing in order to improve efficiency and security. Today, there are five families of homomorphic schemes, based on ideal lattices, integers, NTRUEncrypt, (Ring) Learning With Errors and Approximate Eigenvalues, respectively. Some constructions are better in security, others in efficiency, and others exhibit fancy properties (let us highlight the Multikey FHE scheme of Lopez-Alt \etal \cite{Lopez-alt12on-the-flymultiparty}, the provable circular-secure of Brakerski \etal \cite{Brakerski:2011:FHE:2033036.2033075}, and the attribute-based of Gentry \etal \cite{GSAB13}). Recent proposals greatly outperform the original ideal lattices scheme as they are better in efficiency, more suited for applications and less complex in structure. This is why the original scheme has lost attention. In spite of this, we review the first somewhat FHE scheme briefly, in an effort towards suggesting that it is not very complex. 

\subsection{FHE and chosen ciphertext attacks}
It is known that FHE schemes cannot resist CC-2 attacks, \ie when an adversary aims to decrypt a challenge ciphertext with the help of an oracle that decrypts ciphertexts under the corresponding key. The reason for this is that the attacker is not allowed to submit the challenge, but as the scheme is homomorphic they can transform it into a different ciphertext using identity homomorphic operations (such as $m\mapsto m\oplus 0$) and submit the result. Of course, this does not mean that the secret of the oracle can be retrieved by the adversary in a CC attack. Precisely, the aim of this paper is to show that the original scheme proposed by Gentry allows a CC-1 attacker to recover the secret key in polynomial time.

\subsection{Our Contributions}
We first show how to use an ad-HPP solver to recover a secret key of Gentry's scheme. We propose two algorithms that solve ad-HPP. Our first proposal consists in guessing sufficiently many points near the boundary and then approximating an edge of the parallelepiped (which recovers the full secret by rotations). It uses $O(n^2\log D)$ adaptive calls to $\chi$. Our second and more promising proposal imitates the effect of gravity, bouncing repeatedly against $\partial P$ and converging to a vertex. To this end, after $n$ bounces the attacker computes the $(n-1)$-surface generated by the $n$ bouncing points, and repeats the process from the circumcenter of these points. We prove that $\lceil\log(D)\rceil$ repetitions are enough to output a vertex, therefore two neighbor vertices can be found adaptively by submitting $O(n\log^2(D))$ points to $\chi$. With this, retrieving the secret key of Gentry's scheme can be done with $O(n\log^2 n)$ adaptive calls to the oracle. We give a complete analysis and proof of our attack. 
\subsection{Related Work}
The Hidden Parallelepiped Problem has already been used in cryptanalysis in its non-adaptive form, \ie, guess the parallelepiped given a list of random uniformly distributed points in its interior, without access to the indicator function or the integer vertices hypothesis. In \cite{Nguyen2009}, Nguyen and Regev introduced a nice algorithm solving the Hidden Parallelepiped Problem based on an optimization problem on a $n$-hypercube after proper transformations. We refer to it as the Nguyen-Regev algorithm. They applied it to cryptanalyze NTRU and GGH signature schemes, reporting full recovery of NTRU secret keys using only 400 message-signature pairs for advised parameters. In the adaptive version of HPP that we introduce, the attacker may generate a list of interior points using the indicator function and feed the NR algorithm to find the parallelepiped. However, a large number of points is required to proceed. Authors overcome this using known symmetries on NTRU lattices, which allow to generate a number of signatures from a given message-signature list. These symmetries are not present in Gentry's ideal lattices.

\section{Preliminaries}

\subsection{Notation}
Vectors in $\RR^n$ are noted with an arrow $\vec{a}$, canonical vectors in $\RR^n$ are noted by bold letters: $\ee_1=(1,0,0,\dots,0)$. If $S$ if a set of vectors of $\RR^n$, $\bra S\ket$ denote the vector space generated by elements in $S$, and $\bra S\ket^\perp$ denote the orthogonal complement of $\bra S\ket$. If $E$ is a set, $e\xleftarrow{\$}E$ means that $e$ was sampled randomly from $E$ using the uniform distribution. Unless stated otherwise, the norm in $\RR^n$ the Euclidean norm $||\vec x||_2=\sqrt{\sum_i x_i}$. $\mathcal{B}_k(c,r)$ is the $k$-th dimensional ball centered in $c$ of radius $r$, and $\meas_k(\cdot)$ is the usual $k$-dimensional Lebesgue measure. The unit ball of dimension $k$ is $\mathcal{B}_k(0,1)$, and its measure is given by $\pi^{n/2}/\Gamma(n/2+1)$. If $P$ is a polytope, $\partial P$ denotes its boundary. The $2n$-th dimensional hyperplanes delimiting the interior of a parallelepiped are called facets, and the lines connecting two consecutive vertices are called edges. Two vertices are said to be neighbors if there is an edge that connects them. Overloading notation, if $p(x)$ is a polynomial of degree $n-1$, its coefficient vector $\alpha(p)$ will be also noted $p$. If $(g)$ is an ideal in $R$, the ideal lattice $\alpha((g))$ will be also noted $(g)$. The rotation basis of $(g)$ is denoted by $\rot(g)$. Bases of ideal lattices will be noted with bold letters. All lattices in this article are of full rank, we identify their bases with square matrices. Let $I_n$ be the $n\times n$ identity matrix.


\subsection{Lattices}
\label{subsec:lattices}
\begin{DEF}[Lattice]\label{def:lattice}
	A lattice in $\RR^n$ is a discrete subgroup of $(\RR^n,+)$ which spans $\RR^m$ as a $\RR$-vector space.	
\end{DEF}
Every lattice $L$ has a minimal subset of $m$ elements $B\subset L$ such that $L=\bigoplus_{b\in B}\ZZ b$. When $n\geq 2$ there is an infinite number of such sets and we call them {\it bases} of $L$. The integer $m$ does not depend on the chosen basis and is called the {\it rank} of $L$, therefore, to describe a lattice, only one basis is required. Given a basis of rank $m$ in matrix form $\BB=(\bb_1|\bb_2|\cdots|\bb_m)$, the quantity $|\!\det(\BB)|:=\sqrt{\det({}^t\BB\BB)}$ is an invariant of $L$, which we note by $\det L$. Let the {\it fundamental parallelepiped} of the basis $\BB$ be the translated convex hull delimited by the column vectors in $\BB$. We note this parallelepiped by $P(\BB)=\left\{\sum_{1\leq i\leq m} x_i\mathbf{b}_i\in\RR^n\; ;\; x_i\in [-1/2,1/2)\right\}$. By definition, the volume of $P(\BB)$ equals the determinant of the lattice:
$\det(L)=\RR^n\mbox{-measure}(P(\BB))\mbox{ for any basis }\BB.$
Let $L$ be a full rank lattice. If $x\in \RR^n$, we note by $x\!\!\mod L$ the equivalence class of $x$ in the quotient group $\RR^n/L$. We use the fundamental parallelepiped $P(\BB)$ as the set of representatives of the equivalence classes when describing $L$ with the basis $\BB$. Therefore, it is natural to note by $x\!\mod \BB$ the singleton in $(x\!\mod L)\cap P(\BB)$. To reduce a vector $x\in \RR^n$ modulo $\BB$, use $\ZZ$-linear combinations of vectors in $\BB$ to find the equivalent vector inside $P(\BB)$. In other words,
\begin{LEM}
Let $x\in \RR^n$ and $\BB$ a basis of a full-rank lattice $L$. Then $x\!\!\mod\BB=x-\BB\lfloor \BB^{-1} x\rceil$, where $\lfloor v \rceil:=(\lfloor v_1 \rceil,\lfloor v_2 \rceil,\cdots,\lfloor v_n \rceil)$ is the closest $\ZZ^n$ vector to $v$.
\end{LEM}
In the scheme, two {\it coprime} lattices $I,J$ will define the plaintext and ciphertext space respectively. 
\begin{DEF}[Relatively prime lattices]
Two lattices $L,L'$ of $\ZZ^n$ are relatively prime (or coprime) if their sum is $\ZZ^n$. We note this $(L,L')=1.$
\end{DEF}
Keys in Gentry's scheme are lattice bases, which we identify with square matrices. The private-key is a ``good'' basis in the orthogonality defect sense and the public key is an eccentric, large basis of the same lattice. More precisely, this large basis is the {\it Hermite Normal Form} of the lattice.
%\begin{DEF}[Hermite Normal Form]
%A square matrix $\mathbf{H}\in \mathcal{M}_{n\times n}(\ZZ)$ of entries $h_{ij}$ is in Hermite Normal Form if 
%\begin{enumerate}
%\item $\mathbf{H}$ is lower triangular, semi-positive definite: $h_{kk}\geq 0$ and $h_{ij}=0$ for $i<j$.
%\item The pivot (first nonzero entry) of a column is strictly below the pivots of precedent columns.
%\item Entries to the right of pivots are zero and elements to the left of pivots are nonnegative, strictly smaller than the pivot.
%\end{enumerate}
%\end{DEF}
%A lattice is uniquely defined by a matrix in HNF, and according to this one can define the HNF of a lattice as its unique basis in HNF.
%\subsection{Notation}
%In this Chapter, all lattices are of full rank $(m=n)$ unless stated otherwise. In addition, if $\mathbf{B}=\{\bb_1,\cdots,\bb_n\}\subset L$ is a basis of the lattice $L$, we will not distinguish between $\mathbf{B}$ and the matrix $B=(\bb_1|\bb_2|\cdots|\bb_n).$ We note by $I_n$ the $n\times n$ identity matrix and $\mathbf{e}_k$ the $k$-th column of $I_n$.
\subsection{Polynomial ideal lattices}

Let $(R,+,\times)$ be a commutative ring and $\alpha:R\to \RR^n$ an additive group homomorphism, then $\alpha(R)$ is a lattice. This yields because $\alpha$ transports the additive structure of $R$ to points in $\RR^n$ in order to generate linear integer combinations of them.
\begin{DEF}[Ideal lattice]
	Let $A$ be a commutative ring and $\alpha:A\to \RR^n$ an additive ring homomorphism. An {\it ideal lattice} of $\RR^n$ is a lattice of the form $\alpha(I)$ for a principal ideal $I\subset A$.
\end{DEF}	

\label{subsec:polynomialprincipalideallattices}
Consider the ring $R=\ZZ[x]/(f(x))$ where $f$ is a monic polynomial of degree $n$, and the natural homomorphism $\alpha: R\to \ZZ^n$ given by $\alpha: a(x)= a_0+a_1x+\cdots+a_{n-1}x^{n-1}\mapsto=(a_0,\dots,a_{n-1}).$
We can now define a precise ideal lattice: if $I=(v)$ is a principal ideal of $R$, then $\alpha(I)$ is a lattice of $\RR^n$ with a remarkable basis:
\begin{LEM}\label{lem:rot}
Let $v\in R$, $I=(v)$ and $v_i= v\times X^i\mod f(X)$ for $i=1,\dots,n-1$. Then a basis of the ideal lattice $\alpha(I)$ is given by a linearly independent subset of  
$$\operatorname{rot}(v):=\{v,v_1,v_2,\cdots,v_{n-1}\}.$$
\end{LEM}
%{\it Proof :} If $w\in (v)$, then $w=v\times a=v\times\left(\sum_{i=0}^{n-1}a_iX^i\right)$ for some $a\in A$. Hence $\alpha(w)=\sum_{i=0}^{n-1}a_i v_i\in \rot(v)$. Conversely, if (the vector) $w\in \rot(v)$, then $w=\sum_{i=0}^{n-1}a_i\alpha(v_i)=\alpha(P)$ for $P=\sum_{i=0}^{n-1}a_iv_i.$ $\square$
%\medskip 
%\begin{REM}
%The ideal lattice $\alpha(I)$ may not be of full rank (hence the ``given by a linearly independent set of'' statement). For instance, if $R=\ZZ[x]/(x^n-1)$ then the ideal lattice $\alpha((1+x+x^2+\dots+x^{n-1}))$ is of rank 1. This happens because the polynomial $1+x+x^2+\dots+x^{n-1}$ is not invertible in $R$. We do not worry much about this, and we will deal only with full-rank lattices, thanks to the choice of the polynomial ring and the ideal generator.
%\end{REM}
%From now on, we will not distinguish between the polynomial $w\in R$ and the corresponding vector $\alpha(w)\in \ZZ^n$. Sometimes, we will not distinguish between a polynomial ideal $(v)$ and the corresponding ideal lattice $\alpha((v))$.
\begin{DEF}[Rotation basis]
The set $\{v_i=v\times x^i\!\mod f(x); i=0,\dots,n-1\}$ is called the {\it rotation basis of $(v)$}. The matrix $\rot(v)=(v|v_1|\dots|v_{n-1})$ is called the {\it rotation matrix} of $v$.
\end{DEF}
\begin{PROP}[Inversing rotation matrices]
Let $v\in R^\times$. Then $\rot(v)\times \rot(v^{-1})=I_n$.
\end{PROP}
%The proof follows directly from the fact that for every $a,b\in \ZZ^n$, $a\times b=\rot(a)b=\rot(b)a$. $\square$.
%\begin{EXA}
%If $n=4$ and $R=\ZZ[x]/(x^4+2)$, the ideal lattice $\alpha((v))$ where $v(x)=1+x^2=(1,0,1,0)$ is generated by
%\begin{align*}
%v(x)\mod f(X)&=1+x^2=(1,0,1,0),\\
%xv(x)\mod f(X)&=x+x^3=(0,1,0,1),\\
%x^2v(x)\mod f(X)&=-2+x^2=(-2,0,1,0),\\
%x^3v(x)\mod f(X)&=-2x+x^3=(0,-2,0,1),
%\end{align*}
%i.e. by the columns of the matrix 
%$$\rot(1+x^2)=
%\left(
%\begin{matrix}
%1 & 0 & -2 & 0\\
%0 & 1 & 0  & -2\\
%1 & 0 & 1  &  0 \\
%0 & 1 & 0  & 1
%\end{matrix}
%\right).
%$$
%This matrix is invertible, and therefore the corresponding ideal lattice is of full-rank, with $\det(\rot(1+x^2))=9$.
%\end{EXA}
%Let us give another example which we will find very often in fully homomorphic encryption schemes, in various forms.
%\begin{EXA}
%If $f(x)=x^n-1$, the rotation of a polynome $a(x)\mapsto xa(x)\mod f$ corresponds to a coefficient-wise rotation of $\alpha(a)$:
%$$(a_0,\dots,a_{n-2},a_{n-1})\mapsto (a_{n-1},a_0,\dots,a_{n-2}),$$
%therefore the ideal lattice $(a)$ is generated by the columns of the {\it circulant} matrix 
%$$\rot(a_0,\dots,a_{n-1})=
%\left(
%\begin{matrix}
%a_0 & a_{n-1} & a_{n-2} & \cdots &a_1\\
%a_1 & a_0 & a_{n-1}  &  & a_2\\
%a_2 & a_1 & a_{0}  &   & a_3\\
%\vdots &  &   & \ddots& \vdots \\
%a_{n-1} & a_{n-2} &a_{n-3}&\cdots  & a_0
%\end{matrix}
%\right).$$
%Lattices generated by circulant bases (or equivalently, ideal lattices of the ring $\ZZ[x]/(x^n-1)$) are called {\it cyclic lattices}. They verify the following property: if $(a_1,a_2,\dots,a_n)\in L$ then $(a_2,a_3,\dots,a_n,a_1)\in L.$ Notice also that all of these lattices contain vectors in the lines spanned by $(1,1,1,\dots ,1)$ and $(1,-1,1,\dots,\pm1)$.
%\end{EXA}
																
											
\subsection{Key-Recovery Attacks against SHE schemes}
A chosen ciphertext attack against a public encryption scheme is an attempt to recover a secret of the scheme. In the standard scenario, the attacker knows all public values of the scheme (including the scheme's design). They face a challenge: an oracle possessing a secret publishes the encryption of a random message $r$ and the goal of the attacker is to guess the message. To this end, they may engage in exchanges. In these, the attacker submits a set of ciphertexts of his choice (different from the challenge ciphertext) and the oracle responds with the decryption of each ciphertext. If the publication of the challenge occurs after all exchanges, the attack is said to be a non-adaptive chosen ciphertext attack (or CC-1). If instead the attacker is allowed to perform queries after the challenge is published, the attack is called {\it adaptive chosen ciphertext attack} (or CCA-2). The attack is successful whenever the attacker is able to guess $r$ with better probability than a third party who guesses the plaintext without access to any decryption oracle. %A successful CCA-2 attack implies that an attacker may decrypt challenge ciphertexts, given an adaptive exchange with an oracle.
If the attacker does not only win the CC-1 or CC-2 game with good probability but also retrieves the oracle's secret, the attack is said to be a Key-Recovery (KR) attack. This type of attack is evidently stronger than a CC attacks. FHE schemes cannot achieve security against CC-2 attacks, since the attacker may simply transform the challenge ciphertext $C$ into a different ciphertext $C'$ encrypting the same message (for instance, generating an encryption of 0 and applying the function $m\mapsto m+0$ homomorphically), and then asking the decryption of $C'$ in the exchange. However, it is not proven that somewhat homomorphic schemes are CCA-1 or KR insecure. To the date, a number of KR attacks against SHE schemes have been published, including an attack against a variant of Gentry's ideal lattice scheme, see \cite{Loftus:2011:CSH:2186839.2186845}. The attack we propose is, to the best of our knowledge, the first direct KR attack to \cite{Gentry:2009:FHE:1536414.1536440}.
\medskip 

Let us specify the KR game addressed by our attack. Let $\mathcal E=(\KeyGen,\Enc,\Dec)$ be a public encryption scheme and let $(\sk,\pk)\leftarrow \KeyGen(1^\lambda)$. Let $\mathcal O$ be an oracle that possesses $\sk$ and assume there is an adversary $\mathcal{A}$ with knowledge of every public element of the scheme.
\medskip

{\bf Key-Recovery Game.} 
\begin{enumerate}
	\item $\mathcal A$ generates a ciphertext $c$ and sends it to $\mathcal O$.
	\item $\mathcal O$ computes the underlying plaintext $m$ and sends it to $\mathcal A$.
	\item Repeat the two last steps $\ell$ times.
	\item $\mathcal{A}$ makes a guess $\sk'$, and wins if $\sk'=\sk$.
\end{enumerate}
We say that the attack is successful if $\mathcal{A}$ wins the game with better probability than a random guesser. 

\section{Gentry's ideal lattice homomorphic encryption scheme}
With the homomorphism $\ZZ^n\simeq R=\ZZ[x]/(f(x))$, ring operations are inherited by structure transport. This way, for all $v,w\in \ZZ^n$ and a basis $\BB$ we define
\begin{align*}
&\mbox{addition  }v+w:=\alpha(v(x)+w(x)),\\
&\mbox{product  }v\times w:=\alpha(v(x)\times w(x)),\\
&\mbox{basis reduction }v\!\!\!\!\mod\BB := v - \BB \lfloor \BB^{-1}v\rceil.
\end{align*}
The first operation is usual addition in $\ZZ^n$ and the second one is a convolution product in $\ZZ^n$. We are now ready to define the scheme. The scenario of this scheme is as follows

\begin{itemize}
	\item[--]  Fix a dimension $n\geq 2$ and a monic polynomial $f$ of degree $n$. To prevent lattice reduction attacks, $n$ must be sufficiently large.
	\item[--]  Let $R=\ZZ[x]/(f(x))$. In order to control the norm of products, $f$ is of the form $X^n+h(X)$ where deg$(h)$ is small (for instance $h(X)=-1$).
	\item[--]  Let $I$ be an ideal lattice with a basis $\BB_I$. The binary plaintext case is set with $I=(2)$.
	\item[--]  Let $J$ be an ideal lattice relatively prime to $I$, with two bases $\BB_J^{\sk},\BB_J^{\pk}$. The secret $\BB_J^\sk$ is quite orthogonal, with large volume such that $P(\BB_J^\sk)$ contains $P(\BB_I)$, and $\BB_J^\pk$ is very eccentric (defined by large and almost parallel vectors).
	\item[--]  Choose an algorithm $\Samp:\ZZ^n/(I)\to\ZZ^n$ that given a vector $x$, samples randomly from $x+(I)$. The samples should lie inside a ball of fixed radius $l_\Samp$ contained in $P(\BB_J^\sk)$.
\end{itemize}
The plaintext space in the scheme is $\mathcal{P}:=\ZZ^n\cap P(\BB_I)$ (a small, quite orthogonal parallelepiped) and ciphertext space is $\ZZ^n\cap P(\BB_J^\pk)$ (a huge, very eccentric parallelepiped). The elements $n,f,I,J,\BB_I$ are all public, and the keys are $\pk = \{\BB_J^\pk\}, \sk = \{\BB_J^\sk\}.$
The scheme is described in \ref{algo:gentry}.

\begin{algorithm}[h]
	\small
	\caption{Gentry's homomorphic ideal lattice scheme}
	\label{algo:gentry}
	\begin{algorithmic}[1]
		\Function{\KeyGen}{$\lambda$}
		\State Generate $\BB_J^\sk$ and $\BB_J^\pk$ randomly from a security parameter.
		\EndFunction
		\Statex --------
		\Function{\Enc}{\pk,$\pi\in P(\BB_I)$}
		\State To encrypt message $\pi$, compute
		$$\psi\leftarrow \Samp(\pi)\!\mod \BB_J^\pk$$
		and output $\psi$. It is an integer vector of the form $\pi+i+j$ where $i\in I,j\in J$, and it is inside $P(\BB_J^\pk)$.
		\EndFunction
		\Statex --------
		\Function{\Dec}{\sk,$\psi$}
		\State To decrypt $\psi$, compute
		$$\mu=(\psi\!\!\!\! \mod\BB_J^\sk )\!\!\!\!\mod \BB_I = (\psi - \BB_J^\sk\lfloor(\BB_J^\sk)^{-1}\psi\rceil)\!\!\!\!\mod \BB_I$$
		and output $\mu$.
		\EndFunction
		\Statex --------
		\Function{\Eval}{(\pk,C,$\psi_1,\cdots,\psi_t$}
		\State Perform the circuit $C$ on inputs $\psi_1,\cdots,\psi_t$ replacing each ``$+$'' and ``$\times$'' gate of $C$ by addition and multiplication modulo $\BB_J^\pk$ respectively. Output the result.
		\EndFunction
	\end{algorithmic}
\end{algorithm}





\section{The attack}

We assume that $I=(2)$ and that the secret basis is the rotation matrix of a secret polynomial, \ie $\BB_J^\sk:=\rot(v^\sk)$ (this is the setting proposed by Gentry in \cite{Gentry:2009:FHE:1834954} and maintained in later revisions). In other words, plaintexts are binary vectors and the secret basis is generated by any of its elements. This implies that the full parallelepiped may be retrieved when a vector along any edge is known. We first show that any algorithm solving ad-HPP may be used to recover a secret vector in Gentry's scheme: to this end, we define a function $\ZZ^n\to\{0,1\}^n$ that matches the indicator function of $P(\BB_J^\sk)$ over $\ZZ^n$ with overwhelming probability, and estimate the diameter bound using public values.

\subsection{Reduction to ad-HPP}

In order to recover the secret key $\BB_J^\sk$ of the scheme, first remark that only an edge of $P(\BB_J^\sk)$ is sufficient, since it allows to find a polynomial that generates the basis by rotations. Suppose that $I=(2)$, corresponding to the binary plaintext space $\mathcal{P}=\{0,1\}^n$, and recall that the ciphertext space is $P(\BB_J^\pk)$. The decryption equation of a ciphertext $\psi\in P(\BB_J^\pk)$ with secret-key $\BB_J^\sk$ is
$$\Dec(\BB_J^\sk,\psi)=(\psi\!\!\mod \BB_J^\sk)\!\!\mod \BB_I.$$
Now, consider the function $g:\ZZ^n\to P(\BB_I)$:
$$g:x\mapsto (x\!\!\!\mod \BB_I)-\Dec(\BB_J^\sk,x).$$
However, note that $x$ may not lie in the ciphertext space, and the decryption query may be refused depending on the setting. Addressing this, define 
$\theta:\ZZ^n\to P(\BB_I)$ as
$$\theta= g \circ \!\!\!\!\!\!\mod \BB_J^\pk.$$
It follows that $\theta(x)=0$ for all $x\in P(\BB_J^\sk)$ and, with overwhelming probability, $\theta(y)\not=0$ if $y\not\in P(\BB_J^\sk)$. Finally, define $\chi:\ZZ^n\to\{0,1\}$ as follows
$$
x\mapsto \chi(x)=
\left\{
\begin{array}{cc}
1\mbox{ if }\theta(x)=0,\\
0\mbox{ if }\theta(x)\neq 0.
\end{array}
\right.
$$
This function matches the indicator function of $P(\BB_J^\sk)$ in $\RR^n$ with overwhelming probability. Remark also that the attacker can estimate the diameter as $D\approx 2\sqrt{n}\cdot||v^\sk||_2$, or using only public values,
$$D\approx \sqrt{n}\cdot \mbox{Vol}(P(\BB_J^\sk))^{1/n}=\sqrt{n}\cdot\,|\det P(\BB_J^\sk)|^{1/n}=\sqrt{n}\cdot\,|\det P(\BB_J^\pk)|^{1/n}.$$
For correct evaluation of $k$ successive multiplications, $||v^\sk||_2=O(n^k)$, hence $\log D\approx O(\log{n}).$ The attacker guesses the secret key feeding $(\chi,D)$ to an algorithm solving ad-HPP.

\subsection{Feeding Nguyen-Regev's algorithm and Random Scattering}
We first propose a method that solves ad-HPP using the well-known Nguyen-Regev algorithm, and a second proposal that collects information about the facets of $P$. We point out that these two methods require a large number of decryption queries.


Authors in \cite{Nguyen2009} solve non adaptive HPP given a list of uniformly random points in the interior of the secret parallelepiped. They first perform a transformation to obtain a list of points in a hypercube of dimension $n$ and then they recover the shape with a multivariate optimization problem, solving by gradient descent. This gives a first approach to solve ad-HPP in a non adaptive manner: Just ask the decryption of a uniform set of points inside a ball of radius $D/2$. In the first use case of Nguyen and Regev, the knowledge of a point inside a NTRU parallelepiped implies the knowledge of a number of different points. This is because of symmetries in NTRU lattices: as stated in \cite{Nguyen2009}, from a list of 400 points inside the parallelepiped, it is possible to generate 100,400. In Gentry's ideal lattices, however, no such symmetries are present. According to their experimental analysis in GGH signatures, over 200,000 uniformly distributed points are needed to disclose a secret parallelepiped of diameter $\approx 4n$ in dimension $n=400$. Gentry's parallelepiped has diameter $O(n^k)$ where $k$ is the maximum allowed depth of evaluation circuits, drastically increasing the number of required samples. Nevertheless, we point out that new samples can be generated using homomorphic evaluations, although disturbing the uniformity assumption of Nguyen-Regev algorithm. We leave the analysis of this possibility as an open problem.

In the second method we propose, the attacker finds $K=O(n)$ points near a neighborhood of $\partial P$ and fit an hyperplane between them in order to approximate a facet. They repeat the process in other directions, and then solve linear systems to find approximation of vertices.

To find a single point near $\partial P$, the attacker starts from $0$, chooses a random direction $\vec d\in \RR^n$ and tests integer points near $\bra \vec{d}  \,\ket$ (\ie inside the cylinder $\mathcal{B}_{n}(0,\sqrt n)\times \bra \vec{d}  \,\ket$). They can find a point lying within distance of at most $\sqrt{n}$ of $\partial P$ in $O(\log D)$ calls to the membership function. To search the remaining points near the facet, they can repeat this procedure using small perturbations of $\vec d$ of the form $\vec d_i=\vec d+\vec r_i$ for $i=1,\dots,K-1$ with $||\vec r_i||_2\ll ||\vec d||_2$ (in order to avoid other facets). Another approach is to perform the dichotomy search inside a cylinder $\mathcal{B}_{n}(0,r)\times \bra \vec{d}  \,\ket$ for $r> \sqrt n$. Once $K$ points near each facet are found, the attacker fits an hyperplane (for instance using linear least squares). The procedure finds an approximation of a vertex in $O(n^2\log n)$ calls to the indicator function. 

There are many possible descriptions and optimizations of this algorithm, which cost more calls to $\chi$ but gives more precision in the approximation of vertices. We state that this can be carried out in $O(n^2\log n)$ calls to $\chi$ and the result are points at distance at most $O(n)$ from vertices, the algorithm and error analysis being straightforward, and focus in our second proposal.

\subsection{Falling towards vertices}

In this approach, the attacker travels onto vertices imitating the effect of gravity and bouncing against $\partial P$. This is achieved with a first stage of successive falls to find a vertex $V$, and a second stage to find a neighbor vertex $V'$ of $V$. 

\subsubsection{Falling towards $V$}
The aim is to find a vertex of $P$. First choose a set of orthogonal vectors $\vec u_1,\dots,\vec u_{n}$ and start from the center of the parallelepiped, denoted $O$. Using algorithm \ref{algo:touch}, find a point $x_1\in P$ along $\bra \vec u_1\ket$ such that $\dist(x_1,\partial P)< \sqrt{n}$. From $x_1$, repeat the procedure advancing in the inward pointing direction $\pm \vec u_2$ (if there are no such directions, output $x_1$ as the approximate vertex): again use algorithm \ref{algo:touch} along to find a point $x_2\in P$ (hence of the form $x_1+\lambda \vec u_1$ for $\lambda\in \QQ$) such that $\dist(x_2,\partial P)< \sqrt{n}$. Continuing recursively, at step $k$ we have a point $x_k$ near the boundary, from which we choose an inward pointing direction $\pm\vec u_k$. If no such directions are available, output $x_{k-1}$, else travel with algorithm \ref{algo:touch} along $x_{k-1}+\bra\vec u_k\ket$ to find a point $x_k$ near $\partial P$. 
With overwhelming probability, this procedure performs $n$ steps and outputs a point $x_n$ near the boundary. The fall is detailed in algorithm \ref{algo:surface}. The next step is to compute the circumcenter $c$ of $x_1,\dots,x_n$ (\ie, the center of the circumscribed sphere of dimension $n-1$ embedded in $\RR^n$ that contains the points, see algorithm \ref{algo:Circumcenter}). Repeat the fall starting from $x_0\leftarrow c$ in the direction $\vec u_1$ and continue recursively. The whole procedure is detailed in algorithm \ref{algo:Find_Vertex}. We show in theorem \ref{thm:r/2} that this procedure stops, and outputs an approximation of a vertex in  $O(n\log^2(D))$ calls to $\chi$.
\subsubsection{Falling towards $V'$}
When a vertex $V$ is found, one can repeat algorithm \ref{algo:Find_Vertex} to fall into a neighbor vertex, given a proper initial direction to fall into. Let us explain how to establish this direction and justify the correctness of our method. 

\begin{PROP}
	\label{prop:neighbor}
	Let $P$ be a parallelepiped centered in $O$ with a known vertex $V$. Let $\vec v=\overrightarrow{OV}$, and $\vec u\xleftarrow{\$}\bra\vec v\ket^\perp$. Then, with overwhelming probability, there is a vector $\vec w\in \left\{(1-t)v+tu:t\in [0,1]\right\}$ such that a fall inside $P$ in the direction $\vec w$ converges to a neighbor of $V$. 
\end{PROP}
(See appendix \ref{app:proofs} for a proof).

This vector $\vec w$ can be found by dichotomy, which is what we propose in algorithm \ref{algo:secondvertex}. To see why this happens, consider the hypercube $[-1,1]^n$ and let $V=(v_1,\dots, v_n)\in \{-1,1\}^n$ be a vertex. The neighbors of $V$ are $V_1=(-v_1,v_2,\dots, v_n)$, $V_2=(v_1,-v_2,\dots, v_n)$, $\dots,V_n=(v_1,v_2,\dots,-v_n)$. Given $V$, the goal is to find a direction $\vec u$ such that a fall along $\vec u$ converges to one of these vertices. It is easy to see that a fall inside the cube along any direction that points inside the hyperoctant $\{(z_1,\dots,z_n)\in \RR^n:z_i>0\mbox{ for }i=1,\dots,n\}$ converges to $(1,1,\dots,1)$. In the same way, a fall in the random direction $\vec u=(u_1,\dots,u_n)\xleftarrow{\$} \mathbb{S}_n$ converges to the vertex $(\sign(u_1),\dots,\sign(u_n))$ where $\sign(x)=x/|x|$ with overwhelming probability. The result follows by continuity of a linear transformation between $P$ and the hypercube. With this method, only one additional complete fall is necessary to find a neighbor vertex, the fall converging elsewhere can be discarded after one bounce against $\partial P$ because of excessive distances to $V$.

Summing up all procedures, the attacker may find two adjacent vertices $V_1,V_2$ in $O(n\log^2 D)$ calls to $\chi$ as follows:
 \begin{enumerate}
 	\item $V_1\leftarrow$\textsc{Find\_Vertex}$(O,\ee_1,\dots,\ee_n)$.
 	\item $V_2\leftarrow$\textsc{Find\_Neighbor\_Vertex}$(V,\alpha D/\sqrt{n})$ with a constant $\alpha\gtrapprox 1$
 \end{enumerate}
 
 
 With two neighbor vertices, the attacker finally establishes $v^\sk=V_1-V_2$.


\begin{PROP}
	\label{prop:touchborder}
	The \textsc{Touch\_Border} algorithm has a complexity of $O(\log D)$ calls to $\chi$.
\end{PROP}


\begin{PROP}
\label{prop:findvertex}
	The \textsc{Find\_Vertex} algorithm has a complexity of $O(n\log^2 D)$ calls to $\chi$.
\end{PROP}


\begin{algorithm}
	\caption{\label{algo:touch} Finding a point near $\partial P$}
	\begin{algorithmic}[1]
		\Require An indicator function $\chi$ of a parallelepiped $P$, the diameter $D$ of $P$, a point $x_0\in P$, and a unitary vector $\vec u$.
		\Ensure Two points $x\in P$ and $y\not\in P$ such that $\mathrm{d}(x,y)<\sqrt{n}$ and $(x_0,x,y)$ are collinear up to translation of $\sqrt{n}$. 
		\Function{Touch\_Border}{$x,\vec u$}
		\State Let $x_1\leftarrow x_0+D\vec u$\Comment Notice that $x_1\not\in P$
		\State \Return {\sc Touch\_Border\_Rec}$(x_0,x_1,\vec u)$
		\EndFunction 
		\Statex ---------
		\Function{Touch\_Border\_Rec}{$x_{\mbox{\tiny in}},x_{\mbox{\tiny out}},\vec u$}
		\If{$\mathrm{d}(x_{\mbox{\tiny in}},x_{\mbox{\tiny out}})< \sqrt n$} 
		\State \textbf{Return} $(x_{\mbox{\tiny in}},x_{\mbox{\tiny out}})$
		\Else \State Let $y\leftarrow \lfloor x_{\mbox{\tiny in}}+\frac{||x_{\mbox{\tiny out}}-x_{\mbox{\tiny in}}||}{2}\vec u\,\rceil $
		\If{$(\chi(y)=1)$}
		\State \textbf{Return} {\sc Touch\_Border\_Rec}$(y,x_{\mbox{\tiny out}},\vec u)$
		\Else 
		\State \textbf{Return} {\sc Touch\_Border\_Rec}$(x_{\mbox{\tiny in}},y,\vec u)$
		\EndIf
		\EndIf 
		\EndFunction
		\end{algorithmic}
		\end{algorithm}



\begin{algorithm}
	\caption{\label{algo:surface} Orthogonal bounces towards a vertex}
	\begin{algorithmic}[1]
		\Require An indicator function $\chi$ of a parallelepiped $P$, an interior point $x\in P$ and orthogonal vectors $\vec{u_1},\cdots \vec{u_n},\in \mathbb{S}^n$
		\Ensure A set of $n$ points $S\subset \ZZ^n$ such that $\mathrm{d}(y, \partial P) < \sqrt{n}$ for all $y\in S$.
		\Function{Create\_Surface}{$x,\vec{u_1},\dots,\vec{u_n}$}
		\State $y_0\leftarrow x$
		\For{$i= 1$ to $n$}
		\If{$\chi(\lfloor y_{i-1}+\vec u_i \rceil)=1$}
		\State $y_i\leftarrow${\sc Touch\_Border}$(y_{i-1},\vec u_i)$
		\Else
		\State $y_i\leftarrow${\sc Touch\_Border}$(y_{i-1},-\vec u_i)$
		\EndIf

		\EndFor
		\State \Return $\{y_1,\dots,y_n\}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{\label{algo:Find_Vertex}Fall onto a vertex}
	\begin{algorithmic}[1]
		\Require An interior point $x_1\in \ZZ_n$ of a parallelepiped $P$, the diameter $D$ of $P$, and a set of orthogonal vectors $\vec{u_1},\dots,\vec{u_n}$.
		\Ensure A point in $\ZZ^n$ at distance at most $\ell$ from a vertex of $P$
		\Function{Find\_Vertex}{$x$,$\vec{u_1},\dots,\vec{u_n}$}
		\State $S\leftarrow $\textsc{Create\_Surface}$(x,\vec{u_1},\dots,\vec{u_n}$)
		\State $(x,r)\leftarrow $\textsc{Circumcenter}($S$)
		\State \textsc{Find\_Vertex\_Rec}$(x,r,\vec{u_1},\dots,\vec{u_n})$
		\EndFunction	
		\Statex --------
		\Function{\textsc{Find\_Vertex\_Rec}}{$x,r,\vec{u_1},\dots,\vec{u_n}$}
		\If{$r< 1$}
		\State \Return $x$
		\Else 
		\State $S'\leftarrow$\textsc{Create\_Surface}$(x,\vec{u_1},\dots,\vec{u_n})$
		\State $(x',r')\leftarrow$\textsc{Circumcenter}$(S')$
		\State \Return \textsc{Find\_Vertex\_Rec}$(x',r',\vec{u_1},\dots,\vec{u_n})$
		\EndIf 
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{\label{algo:secondvertex}Finding a neighbor vertex}
\begin{algorithmic}[1]
\Require A center $O$ and a vertex $V$ of a parallelepiped $P$. A superior bound $L$.
\Ensure A vertex $V'$ such that $||V'-V||<L$.
\Function{Find\_Neighbor\_Vertex}{$V,L$}
\State $\vec u \leftarrow V-O$.
\State $\vec v \xleftarrow{\$}\bra \vec{u}\,\ket^\perp$ 
\State \Return \textsc{Find\_Neighbor\_Vertex\_Rec}$(O,V,\vec u,\vec v,L,0,1)$
\EndFunction
\Statex ------ \Comment Look by dichotomy a direction that leads to a neighbor vertex
\Function {Find\_Neighbor\_Vertex\_Rec}{$O,V,\vec u,\vec v,L,a,b$}
\State $t\leftarrow \frac{a+b}{2}$
\State $\vec w\leftarrow (1-t)u+tv$
\State Compute $W'$, an orthogonal base of $\bra w\ket^\perp$
\State $V'\leftarrow $\textsc{Find\_Vertex}$(O,\vec w,W')$
\If{$V=V'$} \Return \textsc{Find\_Neighbor\_Vertex\_Rec}$(V,\vec u,\vec v,L,\frac{a+b}{2},b)$
\ElsIf{$||V'-V||<L$} \Return $V'$.
\Else \;\Return \textsc{Find\_Neighbor\_Vertex\_Rec}$(V,\vec u,\vec v,L,a,\frac{a+b}{2})$
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Proofs of algorithms}
When performing the algorithm, one first chooses a set of orthogonal vectors. Without loss of generality take the canonical vectors $\ee_1,\dots,\ee_n$. Let $x_0\in \ZZ^n$ be a point inside of $P$, and define $S_0\leftarrow$\textsc{Create\_Surface}$(x_0,\ee_1,\dots,\ee_n)$. Recall that $S$ is a set of $n$ points very close to $\partial P$, generated by bouncing against $\partial P$ successively along the directions , $\ee_1,\dots,\ee_n$. Parse $S_0=\{x_1^{(0)},\dots,x_n^{(0)}\}$, and note that the sequence $||x_1^{(0)}||,\dots,||x_n^{(0)}||$ is strictly increasing with overwhelming probability. Now, compute $(c_0,r_0)\leftarrow$\textsc{Circumcenter}$(S_0)$ and define recursively for $i\geq 1$:
$$
\begin{array}{lcl}
S_i&\leftarrow&\mbox{\sc Create\_Surface}(c_{i-1},\ee_1,\dots,\ee_n),\\
S_i&=&\{x_1^{(1)},\dots,x_n^{(1)}\}\\
(c_i,r_i)&\leftarrow&\mbox{\sc Circumcenter}(S_i)
\end{array}$$

\begin{PROP}
	 The program \textsc{Find\_Vertex} outputs a point in $\ZZ^n$ in a finite number of steps.
\end{PROP}

{\it Proof: } Notice that the integer sequence of bouncing points norms
$$||x_1^{(0)}||,\dots,||x_n^{(0)}||,||x_1^{(1)}||,\dots,||x_n^{(1)}||,||x_1^{(2)}||,\dots||x_n^{(2)}||,\dots$$  
is strictly increasing (each $x_i^{(j)}$ is of the form $x_{i-1}^{(j)}+\lambda\ee_{i}$ for a $\lambda\in \ZZ$), and bounded by the diameter $D$, therefore it converges after a finite number of bounces. $\square$
\medskip

We now quantify the ratio of $(n-1)$-measures of two successive bouncing surfaces in the process of finding a vertex.


\begin{THE}\label{thm:r/2}
	 For all $i\geq 1$, $\frac{r_{i}}{r_{i+1}} \leq \frac{1}{2}$, or equivalently
	 $$\frac{\mathrm{meas}(\mathcal{B}_{n-1}(c_i,r_i))}{\mathrm{meas}(\mathcal{B}_{n-1}(c_{i-1},r_{i-1}))}\leq  \frac{1}{2^{n-1}}.$$
\end{THE}

\begin{proof}
The algorithm works as follows: starting from $c_i$ use algorithm \ref{algo:touch} to find a point $x_1$ near $\partial P$ in the direction $\ee_1$. Proceeding in a direction $\pm\ee_2$ from $x_1$, find a point $x_2$ near $\partial P$, again with algorithm \ref{algo:touch}. Complete the $n$ stages to obtain $n$ points $x_1,\dots,x_n$. Notice that for all $k=2$ to $n$, $x_k=x_1+\sum_{i=2}^{k}\lambda_i\ee_i$ with $\lambda_i\in \ZZ$. Without loss of generality, suppose that $\lambda_i\in\NN^\ast$. In particular, every point $x_i$ is contained in the intersection of the hemispheres 
$\{x\in\mathcal{B}_{n-1}(x_1,r_i): (x-x_1)\cdot \ee_k\geq 0\}$ for $k\geq 2$. Consider now $\mathcal{B}_{n-1}(c_{i+1},r_{i+1})$, where $c_{i+1},r_{i+1}$ are the circumcenter and circumradius of the points $x_1,\dots,x_n$. Since every point of $\mathcal{B}_{n-1}(c_{i+1},r_{i+1})$ lies in the hemisphere $(x-x_1)\cdot \ee_2\geq 0$, a diameter of $\mathcal{B}_{n-1}(c_{i+1},r_{i+1})$ drawn at $x_1$ is strictly less than $r_i$, which implies that $\frac{r_i}{r_{i+1}} \leq 2$ and $\frac{\mathrm{meas}(\mathcal{B}_{n-1}(c_i,r_i))}{\mathrm{meas}(\mathcal{B}_{n-1}(c_{i-1},r_{i-1}))}\leq  \frac{1}{2^{n-1}}$ 
\end{proof}

\begin{COR}
The \textsc{Find\_Vertex} algorithm outputs a vertex of $P$ after $\lceil\log(D)\rceil$ recursive calls.
\end{COR}
\begin{proof}
After $k$ iterations, $r_k\leq \frac{r_0}{2^k}<\frac{D}{2^k}$, and $r_k<1$ is therefore reached after $\log D$ iterations. 
\end{proof}

\section{Conclusion}

We proposed a new key recovery attack on Gentry's ideal lattice fully homomorphic scheme. This attack recovers completely the secret key, reducing to a geometric problem called adaptive Hidden Parallelepiped Problem. We propose two solutions, one of them exposing the secret in $O(n\log^2 D)$ adaptive calls to the decryption oracle. It would be interesting to see an implementation, and to analyze the possibility of establishing membership of points in the parallelepiped with help of homomorphic operations. This may contribute to lower the quantity of decryption queries.
\bibliography{biblio}

\newpage

\appendix
\section{Algorithm for the circumcenter of $n$ points}

\begin{algorithm}
	\caption{\label{algo:Circumcenter} Circumcenter of $n$ points}
	\begin{algorithmic}[1]
		\Require A set of $n$ points $S\subset \ZZ^n$ such that no hyperplane of dimension less than $n-2$ contains them.
		\Ensure The center $c$ and radius $r$ of the ball $\mathcal{B}_{n-1}(c,r)\in \RR^n$ that circumscribes the points in $S$.
		\Function{Circumcenter}{$S$}
		\State Parse $S=\{y_1,\dots,y_n\}$
		\State $y_{n+1}\leftarrow y_1$
		\For{{$i=1$  to  $n$}}
		\State $\backslash \backslash$ The hyperplane $\Pi_i$ is the perpendicular bisector of $y_i,y_{i+1}$
		\State $\Pi_i\leftarrow =\{x\in\RR^n:(y_{i+1}-y_i)\cdot (x-\frac{y_{i+1}+y_i}{2})=0\}$
		\EndFor
		\State $c=\bigcap_{i=1}^n \Pi_i$
		\State $r=\mathrm{d}(c,y_1)$
		\State \Return $(c,r)$.
		\EndFunction
		\end{algorithmic}
		\end{algorithm}

\section{Omitted Proofs}
\label{app:proofs}

%	\begin{THE}
%		\label{app:proofneighbor}
%		Let $n \geqslant2$, $\vec{v}=(1,1,\dots ,1)\in \ZZ^n$ and $\vec{u}\in\bra\vec v\ket^\perp$ such that $||\vec{u}||=||\vec{v}||$ and $\vec u$ has a coordinate different to $\pm 1$. Then there is a vector in the set $\{\vec{v}+\vec{u},\vec{v}-\vec{u}\}$ with exactly one negative coordinate.
%\end{THE}
%
%
%\begin{proof}
%	We prove this by induction on the dimension $n$. The base case $n=2$ is straightforward. Suppose the property is true on dimension $k-1$, and let $\vec{v}^{(k)}=(1,1,\dots,1)\in \ZZ^{k}, \vec{u}^{(k)}\in\bra\vec v\ket^\perp$ with a coordinate different than $\pm 1$. Then there exists $i_0 \in \{1,\dots,k\}$ such that $|u_{i_0}^{(k)}|<1$. Now, let  $\vec{w}^{(k-1)}$ be an orthogonal projection of norm $\sqrt{k-1}$ of $\vec u^{(k)}$ to the hyperplane $\Pi_{i_0}=\{(x_1,\dots,x_k)\in \RR^n:x_{i_0}=0\}$, \ie $\vec w^{(k-1)}=\sqrt{k-1}\frac{(\vec u^{(k)}-u_{i_0}^{(k)}\ee_{i_0})}{||\vec u^{(k)}- u_{i_0}^{(k)}\ee_{i_0}||}$ and $\vec{v}^{(n-1)}=\vec{v}^{(n)}-\ee_{i_0}$. Then the vectors $\vec{v}^{(n-1)},\vec{w}^{(n-1)}$ embedded in $\Pi_{i_0}$ are of the same norm and orthogonal.  we have $\vec{w}^{(n-1)} \subset \mathbb{R}^{(n-1)}$, $\vec{w}^{(n-1)} \cdot \vec{a}_{i0}^{(n-1)}=0$ and $||\vec{w}^{(n-1)}||=||\vec{a}_{i_0}^{(n-1)}||$. By the induction hypothesis, there is either $\vec{a}^{(n-1)}+ \vec{w}^{(n-1)}$ or $\vec{a}^{(n-1)}- \vec{w}^{(n-1)}$ that has only one negative coordinate. Then by hypothesis of recurrence among the vectors $\pm \vec{v}^{(n)} + a^{(n)}= \frac{||v^{(n)}-\ee_{i0}v_{i_0}^{(n)}||}{\sqrt{n-1}}(\pm \vec{w}^{(n-1)})+{a}^{(n-1)}+\ee_{i0}(1 \pm v_{i_O}^{(n)})$ only one of them has an index $i_1 \neq i_0$ such that $\vec{v}^{(n)}_{i_1}$ is the only negative coordinate except for $i_0$. One can check that with $|v_{i_0}^{(n)}|<1$ we have $1 \pm \vec{v}^{(n)}_{i_0}>0$, which proves the induction.
%\end{proof}
%


\noindent{\it Proof of proposition \ref{prop:neighbor}.} Consider a linear transformation $\psi:[-1,1]^n\to P$ such that $\psi((1,1,\dots,1))=V$. Let $\vec a=\psi^{-1}(\vec v),\vec b=\psi^{-1}(\vec u)$. Now, let $f:[0,1]\to \RR^n$ such that $f(t):=t\vec a+(1-t)\vec b$. With overwhelming probability, $\vec b$ is not normal to a cube's facet, and in this case as $f(1)=\vec a$ and $f(0)=\vec b$, by continuity of $f$ it follows that there is a value $t_0$ such that $f(t_0)$ has exactly one negative and $n-1$ positive non-zero coordinates (\ie, $f(t_0)$ points inside a neighbor hyperoctant). A fall inside the cube towards this direction converges to a neighbor $C$ of $(1,1,\dots,1)$, therefore a fall inside the parallelepiped towards $\vec w=\psi(f(t_0))$ converges towards $V'=\psi(C)$, a neighbor of $V$.\hfill$\square$
\medskip
\medskip
\medskip


\noindent{\it Proof of proposition \ref{prop:touchborder}.} Let $k$ be the number of recursive calls to \textsc{Touch\_Border}. At each step the function computes a candidate to a point near the border, and reduces by $2$ that distance. Since the initial distance is less than $D$, the result follows.\hfill $\square$
\medskip
\medskip
\medskip

\noindent{\it Proof of proposition \ref{prop:findvertex}.} At the first iteration of \textsc{Find\_Vertex} we have the bound $r_1 \leq D$. Since at each step we divide $r_i$ by $2$, then the number of steps is less than $\log D$. The most costly operation of \textsc{Find\_Vertex} is \textsc{Create\_Surface}, who needs $n$ calls to \textsc{Touch\_Border}. Therefore, \textsc{Create\_Surface} has a complexity of $O( n\log(D))$ calls to $\chi$ yielding the result.\hfill$\square$





\end{document}